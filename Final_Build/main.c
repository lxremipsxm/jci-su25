/*Siddharth Vasudevan
Final_Build/main.c

Intended for complete build

Comments
--------
6/30/25: Created file
*/


//-----Includes-----//
#include <avr/io.h>
#include <stdio.h>
#include <util/delay.h>
#include <stdint.h>
#include <stdbool.h>
#include <stdlib.h>
#include <string.h>

//-----Libs-----//
#include "lib/uart.h"
#include "lib/servo.h"
#include "lib/drv8825_2560.h"
#include "lib/SSD1306.h"


//-----Servo Declarations-----//
void servo_raise(char servo){
    servo_set_pos(servo,50);
    _delay_ms(400);
    servo_set_pos(servo,0);
    _delay_ms(100);

}

//-----Stepper Declarations-----//
static void stepper_pin_set(drv8825_drv_pins_t pin, bool state)
{
    //drv8825_drv_pins_t is an enum of ints. 
    //I will be using PF0-PF7 to control the stepper motor, so 
    //I can just map the pins directly to their own number.

    if ((DDRF & (1<<pin)) == 0){
        DDRF |= (1<<pin);
    }

    if (state) {
        PORTF |= (1<<pin);
    }
    else {
        PORTF &= ~(1<<pin);
    }
    

}

static void stepper_delay_us(uint32_t t_us)
{
    _delay_us(t_us);
}


//Driver config
static drv8825_drv_t drv =
{
    .pin_set = stepper_pin_set,
    .delay_us = stepper_delay_us,
};

//Driver Settings
drv8825_scr_t scr =
{
    .steps_per_revolution = 200,
    .microsteps = 1,
    .rpm = 200,
};



void stepper_move_to_pos(int new_pos, int *current_pos)
{   
    drv8825_set_slp_pin(true);
    if (new_pos > 16) new_pos = 16;
    if (new_pos < 1)  new_pos = 1;

    int diff = new_pos - *current_pos;
    
    if (diff > 8)     
        diff -= 16;
    
    else if (diff < -8) 
        diff += 16;

    uint16_t steps_per_rev = drv8825_get_steps_per_revolution() * drv8825_get_microsteps();
    uint32_t ideal_steps_per_slot = (steps_per_rev * 100UL) / 16UL;  // x100 for fixed-point
    uint32_t movement_steps = (ideal_steps_per_slot * abs(diff)) / 100;

    if (diff > 0)
        drv8825_move_steps(movement_steps, DRV8825_DIR_FORWARD);
    else if (diff < 0)
        drv8825_move_steps(movement_steps, DRV8825_DIR_BACKWARD);

    *current_pos = new_pos;
}


void read_card(int card, char reader, int *current_pos){

    //All this does is use the position at reader A to determine the positions of the other three readers,
    //since they have a constant difference of 4 slots between each. I'll create a wrap-around functionality
    //to easily work with the 1-16 cap I have set in stepper_move_to_pos().
    int new_pos=1;
    char move_servo = 1;

    switch (reader){
        case 'A':
            new_pos = card;
            move_servo=1;
            break;

        case 'B':
            new_pos = card-4;
            move_servo=2;
            break;

        case 'C':
            new_pos = card-8;
            move_servo=3;
            break;

        case 'D':
            new_pos = card-12;
            move_servo=4;
            break;
    }


        if (new_pos <= 0){
            new_pos += 16;    
        }

        stepper_move_to_pos(new_pos, current_pos);
        _delay_ms(100);
        servo_raise(move_servo);
}





//-----Keypad declarations-----//
const char keymap[4][4] = {
    {'1', '2', '3', 'A'},
    {'4', '5', '6', 'B'},
    {'7', '8', '9', 'C'},
    {'*', '0', '#', 'D'}
};

void keypad_init(){
    //Using Port A for keypad
    DDRA = (1 << PA1) | (1 << PA3) | (1 << PA5) | (1 << PA7); //first nibble for rows(output), second for columns (input)
    PORTA = 0xFF; //Pulls inputs HIGH and outputs 5V at outputs
}

char keypad_char() {
    char key = 0;

    while (key == 0) { //wait until character entered
        for (uint8_t row = 0; row < 4; row++) {
            // Set all rows HIGH
            PORTA |= (1 << PA1) | (1 << PA3) | (1 << PA5) | (1 << PA7);

            // Drive current row LOW
            switch (row) {
                case 0: PORTA &= ~(1 << PA1); break;
                case 1: PORTA &= ~(1 << PA3); break;
                case 2: PORTA &= ~(1 << PA5); break;
                case 3: PORTA &= ~(1 << PA7); break;
            }

            _delay_us(5);

            // Read column inputs 
            uint8_t col_input = 0;
            col_input |= (PINA & (1 << PA6)) ? (1 << 0) : 0; //if pin A6 high, bitwise or col_input with 0x01
            col_input |= (PINA & (1 << PA4)) ? (1 << 1) : 0;
            col_input |= (PINA & (1 << PA0)) ? (1 << 2) : 0;
            col_input |= (PINA & (1 << PA2)) ? (1 << 3) : 0;

            for (uint8_t col = 0; col < 4; col++) {
                if (!(col_input & (1 << col))) {
                    key = keymap[row][col];
                    break;
                }
            }
            if (key) break; //wait until a key is pressed
        }
    }

    
    return key;
}


void keypad_string(char *stringAddress){
    OLED_GoToLine(3);
    OLED_DisplayString("Input: ");

    char response;
    uint8_t len = 0;

    while (1){
        response = keypad_char();
        

        if (response == '*') {
            OLED_Clear();
            break;
        }

        if (response == '#') {
            if (len > 0) {
                len--;
                stringAddress[len] = '\0'; // Remove last character
            }
        }

        else if (len < 5){
            stringAddress[len++] = response; //concatenate with previous numbers entered
            stringAddress[len] = '\0'; //add null terminator
            
        }

        OLED_DisplayString("     ");
        OLED_GoToLine(4);
        OLED_DisplayString(stringAddress);

        _delay_ms(350);
    }
}

//-----SSD1306-----//
const char logo[1024] = {
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0xE0, 0xF0, 0x00, 0x00, 0x00, 0xF8, 0x80, 0x00, 0x00, 0xF8, 0xE0, 0x00, 0xC0, 
    0xC0, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0xD8, 0x1C, 0x00, 0x80, 0xA8, 0xA9, 
    0x02, 0x00, 0xE0, 0x7F, 0x73, 0x00, 0x00, 0xF4, 0xE5, 0xE7, 0x00, 0x00, 0x19, 0xEF, 0xF3, 0xE1, 
    0xE0, 0x00, 0xF0, 0x30, 0x0C, 0x0C, 0x03, 0x80, 0xC0, 0xA0, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x04, 0x83, 0x40, 0x48, 0x36, 0x04, 0x09, 0x00, 
    0x60, 0x5A, 0xFD, 0x3D, 0x03, 0x80, 0x78, 0x7F, 0xF7, 0xF3, 0x00, 0x00, 0xFF, 0xFF, 0xA9, 0xFF, 
    0x20, 0x03, 0x00, 0x00, 0x58, 0x48, 0xB7, 0x00, 0x00, 0x00, 0x40, 0xA0, 0xA0, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFE, 0xBE, 0x00, 0x00, 0x80, 0xC0, 0xA0, 0xE0, 0x60, 0x60, 
    0xE0, 0x60, 0xC0, 0x00, 0x00, 0x00, 0xF6, 0xFD, 0xE0, 0x60, 0x20, 0x20, 0x80, 0x60, 0xC0, 0x00, 
    0x00, 0xE0, 0xE0, 0xE0, 0x60, 0x60, 0x60, 0xE0, 0xE0, 0xC0, 0x00, 0x00, 0xC0, 0xA0, 0x60, 0x60, 
    0x60, 0x60, 0x20, 0x00, 0x00, 0x80, 0x40, 0xA0, 0x20, 0x40, 0x40, 0x60, 0x60, 0x80, 0x00, 0x00, 
    0xC0, 0x60, 0xE0, 0x60, 0x40, 0x60, 0xE0, 0x60, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x14, 0x1C, 0x05, 0x02, 0xC3, 0xA0, 0xA8, 0x2A, 0x7E, 
    0x2C, 0x07, 0x03, 0xA0, 0xF8, 0x67, 0xFD, 0xFF, 0x19, 0x01, 0xE0, 0x7C, 0xDF, 0xFE, 0xFB, 0x1B, 
    0x40, 0x00, 0x3E, 0xFC, 0x89, 0xC9, 0x84, 0x00, 0x00, 0x24, 0x04, 0xAB, 0x26, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0xE0, 0xDF, 0xF3, 0x00, 0x00, 0x3F, 0x7F, 0xD9, 0xE0, 0xC0, 0x80, 
    0xA0, 0xBF, 0x7F, 0x1B, 0x00, 0x00, 0xBD, 0xCF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x73, 0xBD, 0x00, 
    0x00, 0xFF, 0xCF, 0xFF, 0x00, 0x00, 0x00, 0x84, 0xFF, 0xD6, 0x00, 0x00, 0xC3, 0xC7, 0xC6, 0xC6, 
    0xBC, 0xDC, 0x78, 0x00, 0x04, 0x3F, 0x7B, 0xE0, 0xC0, 0xC0, 0xC0, 0xE0, 0x7F, 0x3F, 0x06, 0x00, 
    0x18, 0xEF, 0xBF, 0x00, 0x00, 0x00, 0x00, 0xFE, 0xFD, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x05, 0x05, 0x81, 0xA0, 0xC0, 
    0xF8, 0xC6, 0x67, 0x1F, 0x17, 0x05, 0x80, 0xE0, 0x78, 0xAE, 0xEF, 0xFF, 0xED, 0x0F, 0x1F, 0x01, 
    0x81, 0x60, 0x80, 0x80, 0x07, 0x0D, 0x16, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x03, 0x02, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x80, 0x40, 0xE0, 0xE0, 0xE0, 0xE0, 0xA0, 0xE0, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0xC0, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x70, 0xA0, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x01, 0x00, 0x00, 0x08, 0x0C, 0x0E, 0x1B, 0x1F, 0x0F, 0x03, 0x02, 0x03, 0x04, 0x01, 0x00, 0x00, 
    0x00, 0x01, 0x02, 0x02, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0xF8, 0xBF, 0xFF, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE0, 0xD0, 0xD8, 0x1C, 0x0C, 
    0x0C, 0x08, 0x1C, 0xFC, 0xF8, 0xE0, 0x00, 0xF8, 0x9C, 0xFC, 0x0C, 0x0E, 0x06, 0x0A, 0x7C, 0xF8, 
    0x00, 0x00, 0x0C, 0xFF, 0x6E, 0x0C, 0x0C, 0x0C, 0x00, 0x00, 0xF8, 0x9C, 0xFC, 0x0C, 0x0E, 0x0E, 
    0x00, 0x90, 0xB8, 0x1C, 0x0E, 0x02, 0x0A, 0x0C, 0xDC, 0xC8, 0xE0, 0x00, 0x00, 0xCE, 0x73, 0x00, 
    0x00, 0x78, 0xDC, 0x24, 0xCE, 0x4E, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x01, 0x07, 0x0F, 0x1C, 0x1C, 0x18, 0x10, 0x18, 0x18, 0x0C, 0x00, 0x07, 0x0D, 0x1E, 0x18, 
    0x18, 0x10, 0x1C, 0x0F, 0x07, 0x03, 0x00, 0x1F, 0x17, 0x1F, 0x00, 0x00, 0x00, 0x00, 0x1F, 0x1F, 
    0x00, 0x00, 0x00, 0x0F, 0x0F, 0x1C, 0x18, 0x10, 0x10, 0x00, 0x1F, 0x1F, 0x1D, 0x00, 0x00, 0x00, 
    0x00, 0x07, 0x0A, 0x1E, 0x10, 0x18, 0x08, 0x1C, 0x0B, 0x03, 0x03, 0x00, 0x00, 0x1D, 0x0E, 0x00, 
    0x00, 0x18, 0x18, 0x18, 0x18, 0x1D, 0x0F, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};


//-----Main method-----//
int main(void)
{

    //Setup
    OLED_Init();
    OLED_GoToLine(4);
    OLED_DisplayLogo(logo);
    uart_init();
    drv8825_init(&drv, scr);
    servo_start_pwm();
    keypad_init();


    //Stepper Settings
    drv8825_set_rpm(50);
    drv8825_set_steps_per_revolution(200);
    drv8825_set_microsteps(4);
    drv8825_set_microsteps_pin(4);
    int current_pos = 1; // current card at reader A

    char code[4];

    _delay_ms(2000);
    

    while(1){

        OLED_Clear(); //Clear display

        drv8825_set_slp_pin(false);

        OLED_GoToLine(1);
        char current[32];
        sprintf(current, "Card at A:%d", current_pos);
        OLED_DisplayString(current);

        code[0] = '\0'; //clear string  
        
        keypad_string(code);
        int len = strlen(code);




        if ((strcmp(code, "AAA") == 0) || (strcmp(code, "BBB") == 0) || (strcmp(code, "CCC") == 0) || (strcmp(code, "DDD") == 0)){

            char r = 'X';

            if (strcmp(code, "AAA") == 0){
                r = 'A';

            }

            else if (strcmp(code, "BBB") == 0){
                r = 'B';
            }

            else if (strcmp(code, "CCC") == 0){
                r = 'C';
            }

            else if (strcmp(code, "DDD") == 0){
                r = 'D';
            }
            
            else {
                //Do nothing
            }

            OLED_GoToLine(3);
            OLED_DisplayString("All cards to ");

            char readermsg[20];
            sprintf(readermsg, "Reader %c", code[0]);
            OLED_GoToLine(5);
            OLED_DisplayString(readermsg);

            int i;
            for (i=1; i<=16; i++){

                read_card(i, r, &current_pos);

                if (i%3 == 0){
                    drv8825_move_steps(4, DRV8825_DIR_FORWARD);

                }
            }
            
            continue;

        }

        if (len == 2){
            char temp[4];
            temp[0] = '0';
            temp[1] = '\0'; 
            strcat(temp, code);
            strcpy(code, temp);
            len += 1;
        }


        if (len > 3){
            uart_send_string("Invalid input. Input longer than three characters. \r\n");
            OLED_GoToLine(3);
            OLED_DisplayString("Max input 3 chars.");
           
        }

        else if ((code[len-1] != 'A') && (code[len-1] != 'B') && (code[len-1] != 'C') && (code[len-1] != 'D')){
            uart_send_string("Invalid input.  Enter a card number followed by the reader you would like it to be read by. E.g. 1A or 01A.\r\n");
            OLED_GoToLine(3);
            OLED_DisplayString("Incorrect Format.");
            OLED_GoToLine(5);
            OLED_DisplayString("e.g. 01A or 1A");
            

        }

        else {

            uart_send_string(code);
            uart_send_string("\r\n");

            char card_str[3];
            card_str[0] = code[0];
            card_str[1] = code[1];
            card_str[2] = '\0';

            int card_int = atoi(card_str);

            if ((card_int < 1) || (card_int > 16)){
                uart_send_string("Invalid input. Either your input card number is out of bounds, or you've entered a value with the wrong format. ");
                uart_send_string("Enter a card number followed by the reader you would like it to be read by. E.g. 1A or 01A. \r\n");
                OLED_GoToLine(3);
                OLED_DisplayString("Card value out of");
                OLED_GoToLine(5);
                OLED_DisplayString("bounds 1-16.");
                _delay_ms(700);
                continue; 
            }


            /*debug message
            char debug_msg[30];
            sprintf(debug_msg, "current pos before = %d\r\n", current_pos);
            uart_send_string(debug_msg);
            */

            char reader = code[2];

            char msg[32];
            sprintf(msg, "Card %d to reader %c", card_int, reader);

            OLED_GoToLine(4);
            OLED_DisplayString(msg); 
            read_card(card_int, reader, &current_pos);

            
            

            /*debug message 2
            char debug_msg2[32];
            sprintf(debug_msg2, "current pos after = %d\r\n", current_pos);
            uart_send_string(debug_msg2);*/
        

        }

        _delay_ms(500);
       

    }

    return 0;

}